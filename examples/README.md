# Примеры диагностических сообщений

## Настройка и запуск

Для компиляции примеров необходимо в файле `test.sh` указать
путь к директории, в которой производилась сборка GCC и запустить этот файл.

Обратите внимание, что компилятор запускается в обход драйвера (т.е. `cc1`
вместо `gcc`). Именно так проще всего будет запускать компилятор под отладчиком
(если это потребуется).

## Скрипт для Clang

В файле `test-clang.sh` для сравнения приведён скрипт который
собирает те же примеры при помощи компилятора Clang (за исключением `test.f95`,
т.к. Clang не поддерживает Fortran и `indent.c`, т.к. соответствующее
предупреждение реализовано только в GCC). Разумеется, для запуска этого скрипта
потребуется Clang. Этот компилятор умеет выводить некотую часть сообщений в
машинно-читаемом формате.

Раскомментируейте строку

```bash
FLAGS='-c -fdiagnostics-parseable-fixits -fdiagnostics-print-source-range-info'
```

в файле `test-clang.sh` чтобы посмотреть как выглядит этот формат.

## Список примеров

- `simple.c` - простой пример с одной ошибкой
- `include.c`, `header1.h`, `header2.h` - в этом примере ошибка возникает в
   заголовочном файле
- `include.i` - этот файл получен из трёх предыдущих при помощи препроцессора:
  `gcc -E include.c -o include.i`, должен давать результат эквивалентный
  `include.c`
- `printf.c` - в предупреждении выводятся несколько типов данных (`double`,
  `int`) и строка (`'%f'`).
- `macro.c` - пример, в котором ошибка в коде, полученном при подстановке
  макроса (macro expansion).
- `indent.c` - пример нового предупреждения, `-Wmisleading-indentation`. Этот
  пример может оказаться нетривиальным с точки зрения разрабатываемого формата.
  Следуют иметь его в виду.
- `overload.cc` - в отличие от всех предыдущих программ, эта написана на C++.
  Здесь ошибка состоит в том, что объявлено две перегрузки функции `foo` и вызов
  неоднозначен. Компилятор выводит список функций-кандидатов в сообщении об
  ошибке.
- `template.cc` - это пример из письма, которое я вам отправлял ранее.
  Ошибка по сути та же, что и в прошлом примере: неоднозначный вызов функции с
  несколькими перегрузками. Отличия в следующем:
 - перегруженные функции определяются при помощи макроса и компилятор выводит
   соответствующее примечание
 - неоднозначный вызов происходит при инстанцировании шаблонного класса adder
   который в свою очередь вызывает constexpr-функцию add_val (чтобы
   проиницилизаровать статическую constexpr-переменную value). Всю эту цепочку мы
   видим в сообщении об ошибке
 - сообщение "constexpr call flows off the end of the function" - это в
   некоторой степени проблема компилятора. Он не способен корректно продолжить
   разбор программы после реальной ошибки "call of overloaded 'add_overload(int&)'
   is ambiguous".
- `test.f95` - программа на языке Fortran. Обратите внимание, что здесь немного
  отличается внешний вид диагностики.