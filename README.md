# Материал по работе над проектом GCC XML diagnostics

## Полезные ссылки
- [Официальный сайт](https://gcc.gnu.org/) GCC
- Раздел [С чего начать](https://gcc.gnu.org/wiki/GettingStarted) в GCC wiki
  упоминает 10 простых шагов (помимо собственно решения задачи :) ):
 1. Подписать договор о передаче исключительного права. Мы займёмся этим как
    только будет готов патч пригодный для того, чтобы отправить его на ревью
    сообществу разработчиков.
 2. Настроить [git](https://gcc.gnu.org/wiki/GitMirror). Subversion - не наш
    вариант.
 3. Научиться [собирать](https://gcc.gnu.org/wiki/InstallingGCC) GCC из
    исходников.
 4. Научиться [тестировать](https://gcc.gnu.org/wiki/Testing_GCC) GCC
 5. Научиться [отлаживать](https://gcc.gnu.org/wiki/DebuggingGCC) GCC
 6. Подписаться на [списки рассылки](https://gcc.gnu.org/lists.html) gcc и
    gcc-patches, присоединиться тем самым к [сообществу
    разработчиков](https://gcc.gnu.org/wiki/Community).
 7. Правильно [настроить](https://gcc.gnu.org/wiki/FormattingCodeForGCC)
    редактор кода
 8. Сформировать патч и отправить его в рассылку
 9. Начать коммитить патчи самостоятельно (всё ещё впереди ;))
 10. Profit!
- [Видео](http://www.cse.iitb.ac.in/grc/index.php?page=videos) курса "Essential
  abstractions in GCC". Имеются подводные грабли:
 - Видео записано в 2012 году (на сайте есть
   [слайды](http://www.cse.iitb.ac.in/grc/gcc-workshop-13/index.php?page=slides) с
   обновлением от 2013 года). Используется версия GCC 4.6.x, которая
   существенно отличается от текущей (как минимум, сейчас компилятор
   разрабатывается на языке C++, а не C).
 - Много внимания уделено бэкенду (оптимизаторам, генерации кода), а не
   фронтэнду (разбору исходного кода). Нам предстоит работать преимущественно с
   фронтэндом.
 - Большая часть полезных для нас материалов - это части 1 - 4.
- Справочное [Руководство](https://gcc.gnu.org/onlinedocs/gccint/) по
  внутреннему устройству GCC. Достаточно подробное. Стоит проглядеть разделы
  посвящённые структуре директорий и процессу сборки.

## С чего начать

### Работа с репозиторием, сборка и тестирование

Пропробуйте сделать следующее:

- Сделать git clone официальной репы GCC (не путайте с зеркалом на github)
- Установить на компьютер все инструменты, необходимые для сборки и прогона
  тестов GCC (см. [Prerequisites for GCC](https://gcc.gnu.org/install/prerequisites.html)).
  Разобраться, как происходит процесс сборки (в общих чертах). Научиться
  конфигурировать и собирать GCC в простейшем варианте (без дополнительных настроек
  configure).
- Небольшой подводный камень: GCC использует библиотеки MPC, MPFR, GMP и ISL.
  Проще всего скачать при помощи скрипта `contrib/download-prerequisites` - По
  умолчанию GCC компилируется в режиме multilib, т.е. runtime-библиотеки (такие
  как стандартная библиотека C++) компилируются также для i386, соответственно
  может потребоваться наличие в системе бибилиотек (glibc и других) для i386.
  Отключить этот режим можно с помощью configure-опции `--disable-multilib` Не
  забудьте про параметр `-j` (кол-во параллельных процессов) у команды make!

#### Варианты сборки GCC

Научитесь собирать компилятор в некоторых других вариантах (это сильно ускорит
процесс сборки!). Попробуйте сделать следующее:

- Включить поддержку только языков C и C++ (ключ `--enable-languages` скрипте
  `configure`)
- Отключить bootstrap (`--disable-bootrap`)
- Отключить multilib (`--disable-multilib`, если ещё не сделали на прошлом шаге)
- Отключить поддержку локализации (`--disable-nls`)

Далее:

- Соберите GCC без оптимизации и с отладочной информацией (-O0, -ggdb3), см.
  [Building a Debuggable Compiler](https://gcc.gnu.org/wiki/DebuggingGCC#gccbuilddebug) в wiki.
  Этот вариант может потребоваться при отладке.

#### Инкрементальная сборка

Научитесь собирать компилятор инкрементально, т.е. так чтобы при изменении
одного файла пересобирался только этот файл (см. раздел
[Top-Level Bootstrap](https://gcc.gnu.org/wiki/Top-Level_Bootstrap), команда
`make stage1-bubble`), настройте такую сборку в своём редакторе кода.

#### Запуск тестов

Посмотрите (эта информация пригодится в будущем), где (и какие) тесты находятся
в дереве исходников.

Попробуйте сделать следующее:

- Запустить тесты (не забывайте про `make -j...`!), дождаться результатов их
  выполнения. Не пугайтесь, если некоторая часть тестов завершается неудачно.
- Научиться сравнивать результаты тестов. Представьте, что вы внесли измнение в
  компилятор. Как бы вы проверили, что в результате него не произошло регресии
  (т.е. все тесты, которые успешно завершались ранее, по-прежнему завершаются
  успешно)? В директории `contrib` есть несколько полезных скриптов.
- Научиться прогонять отдельные тесты. Выберите один (любой) файл с тестами,
  проверяющими вывод диагностики и запустите его.

### Подсистема диагностики

Я составил несколько простых тестовых примеров с разными диагностическими
сообщениями, чтобы вам было проще начать работать. Все примеры находятся в
директории `examples` (там же есть файл [README.md](examples/README.md)
с пояснениями).

#### API для вывода диагностики

Для вывода диагностических сообщений фронтэнды компилятора пользуются общим API,
описанным в `gcc/diagnostic-core.h` (также используется класс `rich_location`,
определённый в `libcpp/include/line-map.h`).

Найдите в коде примеры примеры использования таких функций, как `error_at` и
`warning_at`. Попытайтесь разобраться в логике их работы (см.
`gcc/diagnostic.c` и `gcc/diagnostic-show-locus.c`). Разберитесь, для чего нужен
класс `rich_location` и как его использовать.

#### libcpp, позиции в файлах

В директории `libcpp` дерева GCC (не путать с фронтэндом языка C++, `gcc/cp`) находится
препроцессор - часть компилятора, отвечающая за обработку таких конструкций
языка, как включаемые файлы (include) и макросы.

Именно libcpp отвечает за информацию о позициях лексем в исходном коде. Работа с
этой информацией нетривиальна т.к. для каждой лексемы требуется хранить (и
делать это эффективно!) информацию о том, из какого заголовочного файла (цепочки
файлов) лексема попала в текущую единицу трансляции, и если она была получена в
результате подстановки макроса, то хранится также цепочка макросов. Если это
объяснение покажется немного путанным, возможно примеры `include.c` и `macro.c`
прояснят что именно подразумевается под "цепочкой файлов" и "цепочкой макросов".

Обратите внимание на комментарии в файле `libcpp/include/line-map.h` (они
довольно подробные) и `libcpp/location-example.txt`.

## Задание №1

Требуется разработать формат диагностических сообщений. Как минимум он должен учитывать
следующие сущности:

- Файлы (с исходным кодом программы)
- Позиции с файле (строка, столбец)
- Типы сообщений: предупреждения и ошибки.
- Опции, контролирующие предупреждения

В формате должно быть учтено следующее:

- Один файл может включать другие файлы (механизм include). Вложенность -
  произвольная
- Одна ошибка может содержать несколько сущностей. Например, "constexpr-вызов в
  параметре шаблона, развёрнутого из макроса".
- Редактор кода не обязан "знать", что такое шаблон или макрос, (т.е. различать
  сущности между собой), но важно что в одной ошибке их может быть несколько, у
  каждой сущности  есть позиция и к каждой из них компилятор может вывести
  примачение "notice")
- Компилятор может предложить вариант исправления ошибки
- Позиция ошибки в файле может быть как "точкой" (т.е. один конкретный символ в
  файле), так и диапазоном ("отрезком").
- Подумайте, какие могут быть способы расширения формата с минимальной "болью"
  как для компилятора так и для IDE. Как IDE смогут распознавать версию формата? 
  Смогут ли они отбросить "непонятные" элементы и показать "понятные"?
 - Пример "расширения". См. файл [printf.c](examples/printf.c). Допустим, что
   вследующей версии GCC сможет "подсвечивать" несовпавшую пару: символ
   форматной строки (`%f`) и соответствующий аргумент функции `printf` (число
   `1`). Как можно будет изменить формат так, чтобы старые редакторы смогли
   вывести осмысленное сообщение об ошибке, а новые версии редакторов распознали
   новую сущность "пара позиций в файле"?
